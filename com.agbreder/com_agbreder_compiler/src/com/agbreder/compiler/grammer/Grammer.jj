options{  JDK_VERSION = "1.5";  STATIC = false;  CACHE_TOKENS = true;  ERROR_REPORTING = false;  JAVA_UNICODE_ESCAPE = true;  DEBUG_PARSER = false;  DEBUG_LOOKAHEAD = false;  DEBUG_TOKEN_MANAGER = false;}PARSER_BEGIN(Grammer)package com.agbreder.compiler.grammer;import com.agbreder.compiler.node.*;import com.agbreder.compiler.node.command.*;import com.agbreder.compiler.node.expression.*;import com.agbreder.compiler.node.expression.lvalue.*;import com.agbreder.compiler.node.expression.rvalue.*;import com.agbreder.compiler.node.expression.rvalue.ternary.*;import com.agbreder.compiler.node.expression.rvalue.binary.*;import com.agbreder.compiler.node.expression.rvalue.primitive.*;import com.agbreder.compiler.node.expression.rvalue.unary.*;import com.agbreder.compiler.node.expression.rvalue.array.*;import com.agbreder.compiler.type.*;import com.agbreder.compiler.util.*;public class Grammer{}PARSER_END(Grammer)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >| < DOT : "." >| < COMMA : "," >| < SEMICOMMA : ";" >| < DOTDOT : ":" >| < OR : "or" >| < AND : "and" >| < EQUAL : "=" >| < NOT : "!" >| < GREATER : ">" >| < LOWER : "<" >| < LPARAM : "(" >| < RPARAM : ")" >| < LARRAY : "[" >| < RARRAY : "]" >| < LBLOCK : "{" >| < RBLOCK : "}" >| < NATIVE : "|" >| < ASK : "?" >| < NUM : "num" >| < STR : "str" >| < BOOL : "bool" >| < OBJ : "obj" >| < CLASS : "class" >| < FUNC : "func" >| < VOID : "void" >| < IF : "if" >| < ELSE : "else" >| < WHILE : "while" >| < REPEAT : "repeat" >| < FOR : "for" >| < NEW : "new" >| < SWITCH : "switch" >| < CASE : "case" >| < RETURN : "return" >| < DEF : "def" >}SPECIAL_TOKEN :{  < SINGLE_LINE_COMMENT :    "//" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    )? >}MORE :{  < "/**" ~[ "/" ] >  {    input_stream.backup(1);  }  : IN_JAVA_DOC_COMMENT| < "/*" > : IN_MULTI_LINE_COMMENT}< IN_JAVA_DOC_COMMENT >SPECIAL_TOKEN :{  < JAVA_DOC_COMMENT : "*/" > : DEFAULT}< IN_MULTI_LINE_COMMENT >SPECIAL_TOKEN :{  < MULTI_LINE_COMMENT : "*/" > : DEFAULT}< IN_JAVA_DOC_COMMENT, IN_MULTI_LINE_COMMENT >MORE :{  < ~[ ] >}TOKEN :{  < STRING :    "'"    (      (~[ "'", "\\", "\n", "\r" ])    | "\\" ([ "n", "t", "b", "r", "f", "\\", "'" ])    )*    "'" >| < BOOLEAN :    "true"  | "false" >| < NULL : "null" >| < ID :    (< LETTER >)    (      < LETTER >    | < CONSTANT >    )* >| < NUMBER : (< ZDIGIT >)+ >| < CONSTANT : < NUMBER > (< DOT > < NUMBER >)? >| < #DIGIT : [ "1"-"9" ] >| < #ZDIGIT : [ "0"-"9" ] >| < #LETTER : [ "a"-"z", "A"-"Z", "_" ] >}RBlock init() :{  RCommand cmd;  RValue exp;  RBlock b = new RBlock();}{  (    cmd = cmd()    {      b.add(cmd);    }  )*  {    return b;  }}RCommand cmd() :{  RCommand c;  RValue exp;}{  c = blockDef()  {    return c;  }| c = ifDef()  {    return c;  }| c = switchDef()  {    return c;  }| c = whileDef()  {    return c;  }| c = repeatDef()  {    return c;  }| LOOKAHEAD(< FOR > < ID >)  c = forNDef()  {    return c;  }| c = forDef()  {    return c;  }| c = returnDef()  {    return c;  }| c = methodDef()  {    return c;  }| c = nativeDef()  {    return c;  }| exp = exp()  {    return new RExpression(exp);  }}RMethod methodDef() :{  RType tp;  Token t;  RValue l;  RCommand cmd = null;  RMethod c = new RMethod();}{  < DEF > tp = typevoid()  {    c.setType(tp);  }  t = < ID >  {    c.setName(new RToken(t));  }  < LPARAM >  (    tp = type() t = < ID >    {      c.addParam(new RVariableNode(tp, new RToken(t)));    }    (      < COMMA > tp = type() t = < ID >      {        c.addParam(new RVariableNode(tp, new RToken(t)));      }    )*  )?  < RPARAM > cmd = cmd()  {    c.setCommand(cmd);  }  {    return c;  }}RBlock blockDef() :{  RCommand cmd;  RBlock c = new RBlock();}{  < LBLOCK >  (    cmd = cmd()    {      c.add(cmd);    }  )*  < RBLOCK >  {    return c;  }}RReturn returnDef() :{  Token t;  RValue l;}{  t = < RETURN > l = exp()  {    return new RReturn(new RToken(t), l);  }}RNative nativeDef() :{  Token tl, tr;  RNative c;  RValue l;}{  < NATIVE > tl = < NUMBER > < COMMA > tr = < NUMBER >  {    c = new RNative(new RToken(tl), new RToken(tr));  }  (    < SEMICOMMA >    (      l = exp()      {        c.addParam(l);      }      (        < COMMA > l = exp()        {          c.addParam(l);        }      )*    )?  )?  < NATIVE >  {    return c;  }}RIf ifDef() :{  RValue l;  RCommand cmd, ecmd = null;}{  < IF > l = exp() cmd = cmd()  (    LOOKAHEAD(< ELSE >)    < ELSE > ecmd = cmd()  )?  {    return new RIf(l, cmd, ecmd);  }}RSwitch switchDef() :{  RValue l;  RCommand cmd, ecmd = null;  RSwitch c = new RSwitch();}{  < SWITCH > l = exp()  {    c.setCondition(l);  }  (    LOOKAHEAD(< CASE >)    < CASE > l = exp()    {      c.addValue(l);    }    cmd = cmd()    {      c.addCommand(cmd);    }  )+  (    LOOKAHEAD(< ELSE >)    < ELSE > cmd = cmd()    {      c.setCommand(cmd);    }  )?  {    return c;  }}RWhile whileDef() :{  RValue l;  RCommand cmd;}{  < WHILE > l = exp() cmd = cmd()  {    return new RWhile(l, cmd);  }}RRepeat repeatDef() :{  RValue l;  RCommand cmd;}{  < REPEAT > cmd = cmd() < WHILE > l = exp()  {    return new RRepeat(l, cmd);  }}RFor forDef() :{  RValue l;  RCommand cmd;  RFor c = new RFor();}{  < FOR > < LPARAM >  (    cmd = cmd()    {      c.addInit(cmd);    }    (      LOOKAHEAD(< COMMA >)      < COMMA > cmd = cmd()      {        c.addInit(cmd);      }    )*  )?  < SEMICOMMA > l = exp()  {    c.setCondition(l);  }  < SEMICOMMA >  (    cmd = cmd()    {      c.addNext(cmd);    }    (      LOOKAHEAD(< COMMA >)      < COMMA > cmd = cmd()      {        c.addNext(cmd);      }    )*  )?  < RPARAM > cmd = cmd()  {    c.setCommand(cmd);  }  {    return c;  }}RForN forNDef() :{  Token t;  RValue l, r;  RCommand cmd;  RFor c = new RFor();}{  < FOR > t = < ID > < EQUAL > l = exp() < COMMA > r = exp() cmd = cmd()  {    return new RForN(new RToken(t), l, r, cmd);  }}RValue exp() :{  RValue l;}{  l = ternary()  {    return l;  }}RValue ternary() :{  Token t;  RValue l, c, r;}{  l = or()  (    LOOKAHEAD(< ASK >)    t = < ASK > c = exp() < DOTDOT > r = exp()    {      l = new RTernary(new RToken(t), l, c, r);    }  )?  {    return l;  }}RValue or() :{  RValue l, r;  Token t;}{  l = equal()  (    LOOKAHEAD(< OR >  | < AND >)    (      LOOKAHEAD(< OR >)      t = < OR > r = equal()      {        l = new ROr(new RToken(t), l, r);      }    | LOOKAHEAD(< AND >)      t = < AND > r = equal()      {        l = new RAnd(new RToken(t), l, r);      }    )  )*  {    return l;  }}RValue equal() :{  RValue l, r;  Token t;}{  l = sum()  (    LOOKAHEAD(< NOT > < EQUAL >  | < EQUAL > < EQUAL >  | < GREATER >  | < LOWER >)    (      LOOKAHEAD(< NOT > < EQUAL >)      (        t = < NOT > < EQUAL > r = sum()        {          l = new RNotEqual(new RToken(t), l, r);        }      )    | LOOKAHEAD(< EQUAL > < EQUAL >)      (        t = < EQUAL > < EQUAL > r = sum()        {          l = new REqual(new RToken(t), l, r);        }      )    | LOOKAHEAD(< GREATER > < EQUAL >)      (        t = < GREATER > < EQUAL > r = sum()        {          l = new REqualGreater(new RToken(t), l, r);        }      )    | LOOKAHEAD(< LOWER > < EQUAL >)      (        t = < LOWER > < EQUAL > r = sum()        {          l = new REqualLower(new RToken(t), l, r);        }      )    | t = < GREATER > r = sum()      {        l = new RGreater(new RToken(t), l, r);      }    | t = < LOWER > r = sum()      {        l = new RLower(new RToken(t), l, r);      }    )  )*  {    return l;  }}RValue sum() :{  RValue l, r;  Token t;}{  l = mul()  (    LOOKAHEAD(< PLUS >  | < MINUS >)    (      t = < PLUS > r = mul()      {        l = new RSum(new RToken(t), l, r);      }    | t = < MINUS > r = mul()      {        l = new RSub(new RToken(t), l, r);      }    )  )*  {    return l;  }}RValue mul() :{  RValue l, r;  Token t;}{  l = unary()  (    LOOKAHEAD(< MULTIPLY >  | < DIVIDE >)    (      t = < MULTIPLY > r = unary()      {        l = new RMul(new RToken(t), l, r);      }    | t = < DIVIDE > r = unary()      {        l = new RDiv(new RToken(t), l, r);      }    )  )*  {    return l;  }}RValue unary() :{  RValue l, r;}{  LOOKAHEAD(< MINUS > element())  < MINUS > l = element()  {    return l;  }| l = element()  {    return l;  }}RValue element() :{  RValue l;  Token t;}{  (    "(" l = exp() ")"  | t = < CONSTANT >    {      l = new RNumber(new RToken(t));    }  | t = < NUMBER >    {      l = new RNumber(new RToken(t));    }  | t = < BOOLEAN >    {      l = new RBoolean(new RToken(t));    }  | t = < STRING >    {      l = new RString(new RToken(t));    }  | t = < NULL >    {      l = new RNull(new RToken(t));    }  | l = id()  )  {    return l;  }}RValue id() :{  RValue l = null, r = null, c = null;  LValue lv;  Token t = null, tl, tr;  RType tp;}{  (    LOOKAHEAD(type() < ID >)    tp = type() tr = < ID >    (      LOOKAHEAD(< EQUAL >)      t = < EQUAL > r = exp()    )?    {      return new RDeclare(new RToken(t), new LIdentify(new RToken(tr)), r, tp);    }  | LOOKAHEAD(lvalue() < EQUAL > exp())    lv = lvalue() t = < EQUAL > r = exp()    {      return new RAssign(new RToken(t), lv, r);    }  | l = rvalue()  | LOOKAHEAD(< NEW > < OBJ > < LARRAY >)    t = < NEW > tl = < OBJ > < LARRAY > r = exp() < RARRAY >    {      l = new RArrayNew(new RToken(t), new RToken(tl), r);    }  )  (    LOOKAHEAD(< LARRAY > exp() < RARRAY > < EQUAL >)    < LARRAY > c = exp() < RARRAY > < EQUAL > r = exp()    {      l = new RArraySet(new RToken(t), l, c, r);    }  |    (      LOOKAHEAD(< LARRAY >)      < LARRAY > r = exp()      {        l = new RArrayGet(new RToken(t), l, r);      }      < RARRAY >    )*  )  {    return l;  }}RValue rvalue() :{  Token t, t1, t2;  RValue l, p;  RCall c;}{  (    LOOKAHEAD(< ID > < LPARAM >)    t = < ID > < LPARAM >    {      l = c = new RCall(new RToken(t));    }    (      p = exp()      {        c.addParam(p);      }      (        < COMMA > p = exp()        {          c.addParam(p);        }      )*    )?    < RPARAM >  | LOOKAHEAD(< PLUS > < PLUS > < ID >)    t1 = < PLUS > t2 = < PLUS > t = < ID >    {      l = new RPreInc(new RToken(t1, t2), new RIdentify(new RToken(t)));    }  | LOOKAHEAD(< MINUS > < MINUS > < ID >)    t1 = < MINUS > t2 = < MINUS > t = < ID >    {      l = new RPreDec(new RToken(t1, t2), new RIdentify(new RToken(t)));    }  | LOOKAHEAD(< ID > < PLUS > < PLUS >)    t = < ID > t1 = < PLUS > t2 = < PLUS >    {      l = new RPosInc(new RToken(t1, t2), new RIdentify(new RToken(t)));    }  | LOOKAHEAD(< ID > < MINUS > < MINUS >)    t = < ID > t1 = < MINUS > t2 = < MINUS >    {      l = new RPosDec(new RToken(t1, t2), new RIdentify(new RToken(t)));    }  | t = < ID >    {      l = new RIdentify(new RToken(t));    }  )  {    return l;  }}LValue lvalue() :{  Token t;}{  t = < ID >  {    return new LIdentify(new RToken(t));  }}RType type() :{}{  < NUM >  {    return RNumberType.DEFAULT;  }| < STR >  {    return RStringType.DEFAULT;  }| < BOOL >  {    return RStringType.DEFAULT;  }| < OBJ >  {    return RObjectType.DEFAULT;  }}RType typevoid() :{  RType t;}{  < VOID >  {    return RVoidType.DEFAULT;  }| t = type()  {    return t;  }}